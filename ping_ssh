#!/bin/bash

#/ ping_ssh: "pings" a network device via ssh to verify it is running.
#/ Sends email notifications if the host is not responding, or the remote
#/ command could not be executed. The script saves state across invocations,
#/ and is designed to run in crontab at regular intervals (no more frequent
#/ than CONNECT_TIMEOUT+1 seconds).

# The SSH host line to connect to. Public-key authentication is required.
SSH_HOST="$1"
if [ -z "$SSH_HOST" ] ; then
    echo "Usage: $0 ssh_host" 2>&1
    exit 1
fi

# How many seconds to attempt to connect for before giving up and recording as
# a failure.
CONNECT_TIMEOUT="5"

# Remote command(s) to run. If multiple, place them in a subshell.
RUN_CMD="(hostname ; uptime)"

# How many failures are allowed before giving up. This is the maximum number of
# failure emails the user will receive.
THRESHOLD="3"

# Email address for notifications (failure, giving up, reconnected).
EMAIL_TO="sam@sjkwi.com.au"

# -- do not modify below this line -- #

SSH_OPTS="-oBatchMode=yes -oConnectTimeout=$CONNECT_TIMEOUT"
FAIL_FILE="/tmp/ping_ssh.fail"

# temp log file
TMP_LOG="`mktemp`"   
exec 3>$TMP_LOG

function clean_exit () {
    exec 3>&-
    rm -f $TMP_LOG
    exit $1
}

function send_email () {
    subj="$1"
    echo "From: $USER@`hostname`
To: $EMAIL_TO
Subject: $subj
X-Mailer: ping_ssh on `hostname`

Hello,

The ping_ssh script running on `hostname` has the following notification for you:

`cat $TMP_LOG`

--
ping_ssh (pid $$)
SSH_HOST=$SSH_HOST
CONNECT_TIMEOUT=$CONNECT_TIMEOUT
THRESHOLD=$THRESHOLD
" | sendmail -t
}

function pass () {
    if [ -f $FAIL_FILE ] ; then
        echo "Remote host $SSH_HOST is back online." >&3
        echo "$out" >&3
        rm -f $FAIL_FILE
        send_email "Alert: Remote host $SSH_HOST is back ONLINE"
    fi
    clean_exit 0
}

function fail () {
    exit_code=$1

    if [ ! -f $FAIL_FILE ] ; then
        echo -n 1 >$FAIL_FILE
        now_failures=1
    else
        prev_failures=`cat $FAIL_FILE`
        now_failures=$((prev_failures+1))
    fi

    check_fail_file
    echo "Recorded $now_failures failures to $FAIL_FILE" >&3
    echo -n $now_failures > $FAIL_FILE
    send_email "Alert: Remote host $SSH_HOST is OFFLINE"

    clean_exit $exit_code
}

function check_fail_file {
    [[ ! -f $FAIL_FILE ]] && return
    failures=`cat $FAIL_FILE`
    if [ $failures -eq $THRESHOLD ] ; then
        echo "Too many failures connecting to $SSH_HOST, giving up" >&3
        echo "Remove $FAIL_FILE to reset this script." >&3
        echo -n $((THRESHOLD+1)) > $FAIL_FILE
        send_email "Alert: Giving up on remote host $SSH_HOST"
        clean_exit 5
    elif [ $failures -gt $THRESHOLD ] ; then
        clean_exit 5
    fi
}

out="`ssh $SSH_OPTS $SSH_HOST "$RUN_CMD" 2>&1`"
ret=$?

if [ $ret -eq 0 ] ; then
    pass "$out"
elif [ $ret -eq 255 ] ; then
    check_fail_file
    echo "Error while connecting SSH session to the remote host." >&3
    echo "The error was: $out" >&3
    fail 2
elif [ $ret -eq 127 ] ; then
    check_fail_file
    echo "Error while running remote command." >&3
    echo "The error was: $out" >&3
    fail 3
else
    check_fail_file
    echo "Unknown error while connecting to remote host." >&3
    echo "The error was: $out" >&3
    fail 4
fi
